<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Heatmap Generator</title>
    <style>
        :root {
            --primary-color: #3B82F6; /* Blue 500 */
            --primary-hover-color: #2563EB; /* Blue 600 */
            --primary-light-color: #EFF6FF; /* Blue 50 */
            --secondary-color: #10B981; /* Emerald 500 */
            --text-primary: #1F2937; /* Gray 800 */
            --text-secondary: #4B5563; /* Gray 600 */
            --text-light: #6B7280; /* Gray 500 */
            --bg-main: #F3F4F6; /* Gray 100 */
            --bg-card: #FFFFFF;
            --bg-header-nav: #FFFFFF;
            --border-color: #D1D5DB; /* Gray 300 */
            --border-light: #E5E7EB; /* Gray 200 */
            --error-color: #EF4444; /* Red 500 */
            --success-color: #10B981; /* Emerald 500 */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --border-radius-sm: 0.25rem; /* 4px */
            --border-radius-md: 0.5rem; /* 8px */
            --border-radius-lg: 0.75rem; /* 12px */

            /* Dark Theme Variables (will be applied via body.dark-mode) */
            --primary-color-dark: #60A5FA; /* Blue 400 */
            --primary-hover-color-dark: #3B82F6; /* Blue 500 */
            --primary-light-color-dark: #1E40AF; /* Blue 800 (adjusted for better contrast with light text) */
            
            --text-primary-dark: #F3F4F6; /* Gray 100 */
            --text-secondary-dark: #D1D5DB; /* Gray 300 */
            --text-light-dark: #9CA3AF; /* Gray 400 */

            --bg-main-dark: #1F2937; /* Gray 800 */
            --bg-card-dark: #374151; /* Gray 700 */
            --bg-header-nav-dark: #111827; /* Gray 900 */

            --border-color-dark: #4B5563; /* Gray 600 - For axis lines */
            --border-light-dark: #4B5563; /* Gray 600 - For grid lines, making them visible against Gray 700 card */
            
            --error-color-dark: #F87171; /* Red 400 */
            --success-color-dark: #34D399; /* Emerald 400 */
            /* Shadows can remain similar or be slightly adjusted if needed, for now, we'll use the same definition and let the dark bg provide contrast */
        }

        /* Basic Reset & Font */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            margin: 0; 
            display: flex; 
            flex-direction: column; 
            min-height: 100vh; 
            background-color: var(--bg-main);
            color: var(--text-primary);
            line-height: 1.6;
        }

        body.dark-mode {
            --primary-color: var(--primary-color-dark);
            --primary-hover-color: var(--primary-hover-color-dark);
            --primary-light-color: var(--primary-light-color-dark);
            
            --text-primary: var(--text-primary-dark);
            --text-secondary: var(--text-secondary-dark);
            --text-light: var(--text-light-dark);

            --bg-main: var(--bg-main-dark);
            --bg-card: var(--bg-card-dark);
            --bg-header-nav: var(--bg-header-nav-dark);

            --border-color: var(--border-color-dark);
            --border-light: var(--border-light-dark);
            
            --error-color: var(--error-color-dark);
            --success-color: var(--success-color-dark);

            /* Example: Adjust shadow for dark mode if needed, or keep them if they look good */
            /* --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.5), 0 2px 4px -1px rgba(0, 0, 0, 0.36); */
        }

        /* Header */
        header { 
            background-color: var(--bg-header-nav); 
            color: white; 
            padding: 15px 30px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            box-shadow: var(--shadow-sm);
            border-bottom: 1px solid var(--border-light);
        }
        header h1 { 
            margin: 0; 
            font-size: 1.6em; /* Slightly larger */
            font-weight: 600;
            cursor: pointer; 
            color: var(--primary-color); /* Use primary color for title */
        }
        header button#logoutButton { 
            background-color: var(--error-color);
            color: white; 
            border: none; 
            padding: 8px 15px; 
            border-radius: var(--border-radius-md); 
            cursor: pointer; 
            font-weight: 500;
            transition: background-color 0.2s ease;
        }
        header button#logoutButton:hover { background-color: #DC2626; /* Red 600 */ }

        /* Navigation */
        nav { 
            background-color: var(--bg-header-nav); 
            padding: 0 20px; 
            /* border-bottom: 1px solid var(--border-light); Removed for a cleaner look */
            box-shadow: var(--shadow-sm); /* Shadow provides separation */
            display: flex; /* Allow buttons to space out nicely */
        }
        nav button.main-nav-button { 
            background-color: transparent; 
            border: none; 
            padding: 15px 20px; 
            cursor: pointer; 
            font-size: 0.95em; 
            margin-right: 5px;
            color: var(--text-secondary);
            font-weight: 500;
            transition: color 0.2s ease, border-bottom-color 0.2s ease;
            border-bottom: 3px solid transparent;
            border-top: 3px solid transparent; /* Balance for active state */
        }
        nav button.main-nav-button:hover { color: var(--primary-color); }
        nav button:disabled { color: var(--border-color); cursor: not-allowed; }
        nav button.active { 
            font-weight: 600; 
            color: var(--primary-color); 
            border-bottom: 3px solid var(--primary-color); 
        }
        
        .page-section { display: none; }
        .page-section.active { display: block; }
        .content-section { display: none; }
        .content-section.active { display: block; }

        /* Main Container */
        .container { 
            flex-grow: 1; 
            max-width: 1100px; /* Slightly wider for modern feel */
            margin: 30px auto; 
            padding: 25px; 
        }

        h2 { font-size: 1.75em; color: var(--text-primary); margin-bottom: 25px; font-weight: 600; }
        h3 { font-size: 1.25em; color: var(--text-primary); margin-bottom: 18px; font-weight: 500; }
        p { margin-bottom: 12px; color: var(--text-secondary); }
        small { color: var(--text-light); font-size: 0.875em; }

        #status, #results { 
            margin-top: 25px; 
            padding: 20px; 
            border: 1px solid var(--border-light); 
            background-color: var(--bg-card); 
            border-radius: var(--border-radius-lg); 
            box-shadow: var(--shadow-md);
        }
        #heatmapImage { max-width: 100%; height: auto; margin-top: 10px; }
        #pointMakerCanvas { border:1px solid var(--border-color); cursor:crosshair; max-width: 100%; height: auto; border-radius: var(--border-radius-md); }
        
        /* Progress Bar */
        .progress-bar-container {
            width: 100%;
            background-color: var(--border-light);
            border-radius: var(--border-radius-md);
            margin-top: 8px;
            height: 22px;
            overflow: hidden; 
        }
        .progress-bar-fill {
            height: 100%;
            width: 0%; 
            background-color: var(--primary-color);
            border-radius: var(--border-radius-md); 
            text-align: center;
            line-height: 22px; 
            color: white;
            font-size: 0.9em;
            transition: width 0.4s ease; 
            white-space: nowrap; 
        }

        /* Analytics Card */
        .analytics-card {
            background-color: var(--bg-card);
            border: 1px solid var(--border-light);
            border-radius: var(--border-radius-lg);
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-md);
        }
        .analytics-card h3 {
            margin-top: 0;
            color: var(--text-primary); 
        }
        .analytics-card .metric {
            font-size: 2.2em;
            font-weight: bold;
            color: var(--primary-color); 
            margin: 10px 0; 
        }
        .quick-actions button { margin-right: 12px; margin-bottom: 12px; }
        .zone-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .zone-item:last-child {
            border-bottom: none;
        }
        .zone-item button {
            padding: 3px 8px;
            font-size: 0.9em;
            background-color: var(--error-color); 
            border-color: var(--error-color);
            border-radius: var(--border-radius-sm);
        }
        .zone-item button:hover {
            background-color: #DC2626; /* Red 600 */
        }

        /* Forms */
        label { display: block; margin-top: 15px; margin-bottom: 6px; font-weight: 500; color: var(--text-secondary); }
        input[type="file"], 
        input[type="text"],
        input[type="datetime-local"] { 
            margin-top: 5px; 
            padding: 10px 15px; 
            border-radius: var(--border-radius-md); 
            border: 1px solid var(--border-color); 
            background-color: var(--bg-card); 
            color: var(--text-primary);
            width: 100%; /* Make inputs take full width of their container */
            font-size: 1em;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        input[type="file"] { 
            padding: 10px; 
            background-color: var(--bg-main);
        }
        input[type="file"]::file-selector-button {
            padding: 8px 12px;
            border-radius: var(--border-radius-sm);
            border: 1px solid var(--border-color);
            background-color: var(--bg-card);
            color: var(--text-secondary);
            cursor: pointer;
            margin-right: 10px;
            transition: background-color 0.2s ease;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: var(--primary-light-color);
            border-color: var(--primary-color);
        }
        input[type="text"]:focus,
        input[type="datetime-local"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); /* Focus ring */
        }

        /* Buttons */
        button, .action-button, button[type="submit"] { 
            margin-top: 10px; 
            padding: 10px 20px; 
            border-radius: var(--border-radius-md); 
            border: none; 
            background-color: var(--primary-color); 
            color:white; 
            cursor:pointer;
            font-size: 1em;
            font-weight: 500;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        button:hover, .action-button:hover, button[type="submit"]:hover {
            background-color: var(--primary-hover-color);
        }
        button:active, .action-button:active, button[type="submit"]:active {
            transform: translateY(1px);
        }
        button:disabled { background-color: var(--border-color); color: var(--text-light); cursor: not-allowed; transform: none;}
        .chart-filter-options { margin-bottom: 15px; }
        .chart-filter-options label { margin-right: 10px; display: inline-block;}
        .chart-filter-options input[type="radio"] { margin-right: 5px;}

        /* History Table */
        #historyTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px; /* Increased margin */
            font-size: 0.875em; /* Slightly smaller for more data density */
            box-shadow: var(--shadow-md);
            border-radius: var(--border-radius-lg); 
            overflow: hidden; 
            background-color: var(--bg-card);
        }
        #historyTable thead tr {
            background-color: var(--primary-light-color); 
            text-align: left;
            border-bottom: 2px solid var(--primary-color); 
            color: var(--primary-color);
        }
        #historyTable th, #historyTable td {
            padding: 12px 15px; /* Uniform padding */
            border-bottom: 1px solid var(--border-light); 
        }
        #historyTable th {
            font-weight: 600; 
        }
        #historyTable tbody tr:nth-child(even) {
            background-color: var(--bg-main); 
        }
        #historyTable tbody tr:hover {
            background-color: var(--primary-light-color); /* Consistent hover */
        }
        #historyTable td {
            color: var(--text-secondary); 
        }
        .history-filename-col, .history-floorplan-col {
            max-width: 180px; /* Adjust as needed */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap; /* Important for ellipsis to work on a single line */
            color: var(--text-primary); /* Make filenames slightly more prominent */
        }
        .history-message-col {
            max-width: 250px; 
            overflow-wrap: break-word;
            word-break: break-word; 
        }
        .history-actions-col a {
            color: var(--primary-color);
            text-decoration: none;
            margin-right: 10px;
            font-weight: 500;
        }
        .history-actions-col a:hover {
            text-decoration: underline;
            color: var(--primary-hover-color);
        }
        .history-table-message-row td {
            text-align: center;
            padding: 20px;
            color: var(--text-light); 
            font-style: italic;
        }
        #historyMessage {
            text-align: center;
            margin-top: 15px;
            color: var(--text-secondary);
        }

        #loadedConfigInfo {
            padding: 15px; background-color: var(--primary-light-color); border-radius: var(--border-radius-md); margin-bottom:20px; border: 1px solid var(--primary-color); color: var(--primary-color);
        }

        /* Dashboard Overview Layout */
        .dashboard-layout-grid {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 25px; /* Gap between main column and sidebar */
        }

        .dashboard-main-column {
            flex: 3; /* Takes up more space, e.g., 70-75% */
            min-width: 0; /* Prevents overflow issues with flex items */
            display: flex;
            flex-direction: column;
            gap: 25px; /* Gap between rows/cards in the main column */
        }

        .dashboard-sidebar-column {
            flex: 1; /* Takes up less space, e.g., 25-30% */
            min-width: 280px; /* Minimum width for the sidebar */
            display: flex;
            flex-direction: column;
            gap: 25px; /* Gap between items in sidebar */
        }

        .dashboard-row-cards {
            display: flex;
            gap: 25px; /* Gap between cards in the row */
            flex-wrap: wrap; /* Allow cards to wrap if not enough space */
        }

        .dashboard-row-cards > .analytics-card {
            flex: 1; /* Each card in the row tries to take equal space */
            min-width: 250px; /* Minimum width for cards in a row before wrapping */
        }

        .quick-actions.analytics-card { /* Style quick actions as a card */
            padding: 20px;
        }
        .quick-actions.analytics-card h3 {
            margin-bottom: 15px;
        }
        .quick-actions.analytics-card button {
            display: block; /* Stack buttons vertically */
            width: 100%;
            margin-bottom: 10px;
            margin-right: 0; /* Resetting any previous horizontal margin */
        }
        .quick-actions.analytics-card button:last-child {
            margin-bottom: 0;
        }
        /* Style for lists within analytics cards for better spacing */
        .analytics-card ul {
            padding-left: 20px; /* Add padding to the list itself */
        }
        
        /* Configure Floorplan Page Specifics */
        #pointsList {
            list-style-type: none;
            padding-left: 0;
            margin-top: 8px;
        }
        #pointsList li {
            background-color: var(--bg-main);
            padding: 8px 12px;
            border-radius: var(--border-radius-sm);
            margin-bottom: 6px;
            border: 1px solid var(--border-light);
            font-size: 0.9em;
        }

        /* Theme Toggle Switch */
        .header-controls {
            display: flex;
            align-items: center;
            gap: 25px; /* Space between toggle and logout button */
        }
        .theme-switch-wrapper {
            display: flex;
            align-items: center;
            gap: 10px; /* Space between switch and label */
        }
        .theme-label {
            font-size: 0.875em;
            color: var(--text-secondary); 
            font-weight: 500;
            user-select: none; /* Prevent text selection on label click */
        }
        .theme-switch {
            position: relative;
            display: inline-block;
            width: 50px; 
            height: 26px; 
        }
        .theme-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color); 
            transition: .3s;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 20px; 
            width: 20px; 
            left: 3px; 
            bottom: 3px; 
            background-color: white; /* Knob color */
            transition: .3s;
        }
        input:checked + .slider { background-color: var(--primary-color); }
        input:focus + .slider { box-shadow: 0 0 1px var(--primary-color); }
        input:checked + .slider:before { transform: translateX(24px); }
        .slider.round { border-radius: 26px; }
        .slider.round:before { border-radius: 50%; }

        /* Zone Map View Specifics */
        #zoneHoverInfo {
            position: absolute;
            background-color: rgba(31, 41, 55, 0.9); /* Dark semi-transparent (Gray-800 based) */
            color: var(--text-primary-dark); /* Light text (e.g., Gray-100) */
            padding: 8px 12px;
            border-radius: var(--border-radius-md);
            display: none; /* Initially hidden */
            pointer-events: none; /* Doesn't interfere with mouse events on canvas */
            font-size: 0.875em;
            box-shadow: var(--shadow-lg); /* More prominent shadow for a floating effect */
            z-index: 1000; /* Ensure it's on top */
            border: 1px solid rgba(75, 85, 99, 0.5); /* Subtle border (Gray-600 based) */
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; /* Smooth theme transition */
        }
        body.dark-mode #zoneHoverInfo {
            background-color: rgba(229, 231, 235, 0.9); /* Light semi-transparent (Gray-200 based) */
            color: var(--text-primary); /* Dark text (e.g., Gray-800) */
            border: 1px solid rgba(156, 163, 175, 0.5); /* Subtle border (Gray-400 based) */
        }


    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <header>
        <h1 id="dashboardTitle" style="cursor:pointer;">RetailSense</h1>
        <div class="header-controls">
            <div class="theme-switch-wrapper">
                <label class="theme-switch" for="themeToggleCheckbox" title="Toggle theme">
                    <input type="checkbox" id="themeToggleCheckbox" />
                    <span class="slider round"></span>
                </label>
                <span id="themeLabel" class="theme-label">Light Mode</span>
            </div>
            <button id="logoutButton">Logout</button>
        </div>
    </header>

    <nav>
        <button id="navDashboardOverview" class="main-nav-button">Dashboard Overview</button>
        <button id="navProcessVideo" class="main-nav-button">Process Video</button>
        <button id="navConfigureFloorplan" class="main-nav-button">Configure Floorplan</button>
        <button id="navZoneMapView" class="main-nav-button">Zone Map View</button>
        <button id="navHistory" class="main-nav-button">History</button>
    </nav>

    <div class="container">
        <!-- Page for Dashboard Overview -->
        <section id="pageDashboardOverview" class="page-section">
            <h2>Store Analytics Overview</h2>
            <div class="dashboard-layout-grid">
                <div class="dashboard-main-column">
                    <div class="dashboard-row-cards">
                        <div class="analytics-card" id="totalVisitorsCard">
                            <h3>Total Visitors Today</h3>
                            <p id="totalVisitorsCount" class="metric">--</p>
                            <small>Based on processed video data for the current day.</small>
                        </div>
                        <div id="zoneAnalyticsContainer" class="analytics-card">
                            <h3>Zone Traffic Analysis (Today)</h3>
                            <div id="zoneTrafficList">
                                <p>Process videos with defined zones to see analysis here.</p>
                            </div>
                        </div>
                    </div>

                    <div class="analytics-card" id="visitorTrendsCard">
                        <h3 id="mainChartTitle">Visitor Trends</h3>
                        <div class="chart-filter-options">
                            <label><input type="radio" name="chartPeriod" value="daily_hourly" checked> Today's Hourly Traffic</label>
                            <label><input type="radio" name="chartPeriod" value="yearly_monthly"> Monthly Trends (Current Year)</label>
                        </div>
                        <p id="peakHoursInfo" style="font-size: 1.1em;">Data not yet available. Process videos to see peak times.</p>
                        <div id="peakHoursChartContainer" style="margin-top:15px; min-height: 300px; /* Slightly increased min-height */ position: relative;">
                            <canvas id="peakHoursChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="dashboard-sidebar-column">
                    <div class="quick-actions analytics-card">
                        <h3>Quick Actions</h3>
                        <button id="quickActionProcessVideo" class="action-button">Process New Video</button>
                        <button id="quickActionCheckHistory" class="action-button">View Processing History</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Page for Processing Video -->
        <section id="pageProcessVideo" class="page-section">
            <h2>Process Video for Heatmap</h2>
            <div id="loadedConfigInfo">
                <p><strong>Loaded Point Configuration:</strong> <span id="loadedFloorplanName">None</span></p>
                <p>Points Status: <span id="loadedPointsStatus">Not Set</span></p>
                <p>Zones Status: <span id="loadedZonesStatus">Not Set</span></p>
                <small style="color: inherit;">If a point configuration and zones are loaded from "Configure Floorplan", those will be used with the floorplan you select below. Otherwise, you must set them up in "Configure Floorplan" first.</small>
            </div>
            <div class="analytics-card">
                <h3>Upload Files & Set Time</h3>
                <p>Select the floorplan image, the video file to be processed, and specify the date and time of the video recording. The currently loaded point configuration and zones (if any) will be applied.</p>
                <form id="heatmapForm" style="margin-top: 20px;">
                    <div>
                        <label for="processVideo_floorplanFile">Floorplan Image File (PNG, JPG):</label>
                        <input type="file" id="processVideo_floorplanFile" name="floorplanFile" accept=".png,.jpg,.jpeg" required>
                    </div>
                    <div>
                        <label for="processVideo_videoFile">Video File (MP4, AVI):</label>
                        <input type="file" id="processVideo_videoFile" name="videoFile" accept=".mp4,.avi,.mov" required>
                    </div>
                    <div>
                        <label for="processVideo_eventTime">Date and Time of Video Recording:</label>
                        <input type="datetime-local" id="processVideo_eventTime" name="videoEventTime" required>
                    </div>
                    <button type="submit" id="generateHeatmapButton">Generate Heatmap</button>
                </form>
            </div>
            <div id="status">
                <p><span id="statusText">Status: Idle</span></p>
            </div>
            <div id="results" style="display:none;">
                <h2>Results</h2>
                <h3>Heatmap Image:</h3>
                <img id="heatmapImage" src="" alt="Generated Heatmap">
                <h3>Processed Video:</h3>
                <a id="videoLink" href="#" download>Download Processed Video</a>
            </div>
        </section>

        <!-- Page for Configuring Floorplan -->
        <section id="pageConfigureFloorplan" class="page-section">
            <h2>Configure Floorplan, Points, and Zones</h2>

            <div class="content-section active analytics-card" id="configStep1Upload">
                <h3>Step 1: Upload Floorplan Image</h3>
                <p>Upload the floorplan image you want to use for the heatmap.</p>
                <div>
                    <label for="configPage_floorplanUploadFile">Floorplan Image (PNG, JPG):</label>
                    <input type="file" id="configPage_floorplanUploadFile" accept=".png,.jpg,.jpeg">
                </div>
                <div id="floorplanPreviewContainer" style="margin-top:15px; display:none;">
                    <h4>Floorplan Preview:</h4>
                    <img id="floorplanPreviewImage" src="#" alt="Floorplan Preview" style="max-width:100%; max-height:300px; border:1px solid var(--border-color);"/>
                </div>
                <button id="goToPointConfigButton" class="action-button" style="margin-top:15px;" disabled>Next: Configure Points</button>
            </div>

            <div class="content-section analytics-card" id="configStep2Points"> 
                <h3>Step 2: Configure Perspective Points</h3>
                <p>Click on the floorplan to select 4 points: Top-Left, Top-Right, Bottom-Right, Bottom-Left of the camera's view on the floorplan.</p>
                <canvas id="pointMakerCanvas"></canvas>
                <div id="pointsCoordinates" style="margin-top:10px;">
                    <p>Selected Perspective Points (up to 4):</p>
                    <ul id="pointsList"></ul>
                </div>
                <div style="margin-top: 20px; display: flex; flex-wrap: wrap; gap: 10px;">
                    <button id="resetPointsButton" class="action-button" style="margin-top:0;">Reset Perspective Points</button>
                    <button id="goToZoneConfigButton" class="action-button" style="margin-top:0;" disabled>Next: Define Zones</button>
                </div>
            </div>

            <div class="content-section analytics-card" id="configStep3Zones"> 
                <h3>Step 3: Define Zones (Optional)</h3>
                <p>Click on the floorplan canvas (shown in Step 2 area) to define polygon points for a zone. Give it a name and save. Zones are drawn in blue.</p>
                <div class="zone-controls-group" style="margin-top: 15px;">
                    <div>
                        <label for="zoneNameInput">Zone Name:</label>
                        <input type="text" id="zoneNameInput" placeholder="e.g., Aisle 1, Cold Section" style="margin-bottom: 10px;">
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                        <button type="button" id="startDrawingZoneButton" class="action-button" style="margin-top:0; flex-grow: 1;">Start/Add Point</button>
                        <button type="button" id="finishCurrentZoneButton" class="action-button" style="margin-top:0; flex-grow: 1;">Finish & Save Zone</button>
                        <button type="button" id="clearCurrentZonePointsButton" class="action-button" style="margin-top:0; flex-grow: 1;">Clear Current Points</button>
                    </div>
                </div>
                <div id="definedZonesList" style="margin-top: 20px; background-color: var(--bg-main); padding:15px; border-radius:var(--border-radius-md); border: 1px solid var(--border-light);">
                    <strong>Defined Zones:</strong> (None)
                </div>
                <button id="saveFullConfigurationButton" class="action-button" style="margin-top:20px; width: 100%;">Save Full Configuration (Points & Zones)</button>
            </div>
        </section>

        <!-- Page for Zone Map View -->
        <section id="pageZoneMapView" class="page-section">
            <h2>Latest Zone Map View</h2>
            <div class="analytics-card">
                <p>Visual representation of zones and traffic from the most recent processed video with defined zones. Hover over a zone to see its activity.</p>
                <div id="zoneMapContainer" style="position: relative; margin-top: 20px; max-width: 100%; border: 1px solid var(--border-color); border-radius: var(--border-radius-md); overflow: hidden;">
                    <img id="zoneMapFloorplanImage" src="" alt="Floorplan with Zones" style="display: block; max-width: 100%; height: auto; border-radius: var(--border-radius-md);">
                    <canvas id="zoneMapOverlayCanvas" style="position: absolute; top: 0; left: 0; pointer-events: auto; border-radius: var(--border-radius-md);"></canvas> 
                    <div id="zoneHoverInfo"></div>
                </div>
                <p id="zoneMapMessage" style="text-align: center; margin-top: 15px;"></p>
            </div>
        </section>

        <!-- Page for History -->
        <section id="pageHistory" class="page-section">
            <h2>Processing History</h2>
            <div class="analytics-card">
                <p>Review the status and results of past video processing jobs. Completed jobs offer links to view the generated heatmap image and download the processed video.</p>
                <table id="historyTable">
                    <thead>
                        <tr>
                            <th>Job ID</th>
                            <th>Video</th>
                            <th>Floorplan</th>
                            <th>People</th>
                            <th>Status</th>
                            <th class="history-message-col-header">Message</th>
                            <th>Event Time</th>
                            <th class="history-actions-col-header">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="historyTableBody"></tbody>
                </table>
                <p id="historyMessage" style="margin-top: 15px; text-align: center;"></p>
            </div>
        </section>
    </div>
    <script>
        const backendUrl = 'http://127.0.0.1:5000';

        // Constants
        const LOCAL_STORAGE_CONFIG_NAME = 'savedConfigName';
        const LOCAL_STORAGE_CONFIG_DATA_URL = 'savedConfigDataURL';
        const LOCAL_STORAGE_CONFIG_POINTS = 'savedConfigPoints';
        const LOCAL_STORAGE_ZONES = 'savedFloorplanZones'; 
        const POLL_INTERVAL_MS = 2000;
        const POINT_MARKER_RADIUS = 5;
        const CANVAS_CONTAINER_SCALE_FACTOR = 0.95;


        // DOM Elements
        const dashboardTitle = document.getElementById('dashboardTitle');
        const logoutButton = document.getElementById('logoutButton');
        const mainNavButtons = document.querySelectorAll('.main-nav-button');
        const pageSections = document.querySelectorAll('.page-section');

        // Dashboard Overview Page
        const totalVisitorsCountElem = document.getElementById('totalVisitorsCount');
        const peakHoursInfoElem = document.getElementById('peakHoursInfo');
        const mainChartTitleElem = document.getElementById('mainChartTitle');
        const chartPeriodRadios = document.querySelectorAll('input[name="chartPeriod"]');
        const quickActionProcessVideoBtn = document.getElementById('quickActionProcessVideo');
        const quickActionCheckHistoryBtn = document.getElementById('quickActionCheckHistory');
        const zoneAnalyticsContainer = document.getElementById('zoneAnalyticsContainer');
        const zoneTrafficList = document.getElementById('zoneTrafficList');

        // Zone Map View Page
        const zoneMapContainer = document.getElementById('zoneMapContainer');
        const zoneMapFloorplanImage = document.getElementById('zoneMapFloorplanImage');
        const zoneMapOverlayCanvas = document.getElementById('zoneMapOverlayCanvas');
        const zoneHoverInfo = document.getElementById('zoneHoverInfo');
        const zoneMapMessage = document.getElementById('zoneMapMessage');


        // Configure Floorplan Page
        const configPage_floorplanUploadFile = document.getElementById('configPage_floorplanUploadFile');
        const floorplanPreviewContainer = document.getElementById('floorplanPreviewContainer');
        const floorplanPreviewImage = document.getElementById('floorplanPreviewImage');
        const goToPointConfigButton = document.getElementById('goToPointConfigButton');
        const pointMakerCanvas = document.getElementById('pointMakerCanvas');
        const pointsList = document.getElementById('pointsList');
        const resetPointsButton = document.getElementById('resetPointsButton');
        const goToZoneConfigButton = document.getElementById('goToZoneConfigButton');
        let ctx = null; 
        // Zone definition elements
        const zoneNameInput = document.getElementById('zoneNameInput');
        const startDrawingZoneButton = document.getElementById('startDrawingZoneButton');
        const finishCurrentZoneButton = document.getElementById('finishCurrentZoneButton');
        const clearCurrentZonePointsButton = document.getElementById('clearCurrentZonePointsButton');
        const definedZonesListDiv = document.getElementById('definedZonesList');
        const saveFullConfigurationButton = document.getElementById('saveFullConfigurationButton');


        // Process Video Page
        const loadedConfigInfo = document.getElementById('loadedConfigInfo');
        const loadedFloorplanNameSpan = document.getElementById('loadedFloorplanName');
        const loadedPointsStatusSpan = document.getElementById('loadedPointsStatus');
        const loadedZonesStatusSpan = document.getElementById('loadedZonesStatus'); 
        const heatmapForm = document.getElementById('heatmapForm');
        const processVideo_floorplanFile = document.getElementById('processVideo_floorplanFile');
        const processVideo_videoFile = document.getElementById('processVideo_videoFile');
        const processVideo_eventTimeInput = document.getElementById('processVideo_eventTime');
        const generateHeatmapButton = document.getElementById('generateHeatmapButton');
        const statusTextSpan = document.getElementById('statusText');
        const statusDiv = document.getElementById('status');
        const resultsDiv = document.getElementById('results');
        const heatmapImageElem = document.getElementById('heatmapImage');
        const videoLinkElem = document.getElementById('videoLink');

        // Client-side state
        let selectedFloorplanImage = null;
        let currentConfigPoints = []; 
        let currentDrawingZonePoints = []; 
        let floorplanZones = []; 
        let originalFloorplanWidth = 0;
        let originalFloorplanHeight = 0;
        let currentJobId = null;
        let peakHoursChartInstance = null;
        let isDrawingZoneMode = false;


        // --- Navigation Logic ---
        function showPage(pageId) {
            pageSections.forEach(section => section.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');
            mainNavButtons.forEach(button => {
                button.classList.remove('active');
                if (button.id === `nav${pageId.replace('page', '')}`) button.classList.add('active');
            });

            if (pageId === 'pageDashboardOverview') updateDashboardOverview();
            else if (pageId === 'pageConfigureFloorplan') {
                 loadConfigIntoPointMaker(); 
                 showConfigStep('configStep1Upload'); 
            }
            else if (pageId === 'pageHistory') fetchJobHistory();
            else if (pageId === 'pageZoneMapView') loadZoneMapView();
            
            updateLoadedConfigDisplay(); 
        }

        function showConfigStep(stepId) {
            document.querySelectorAll('#pageConfigureFloorplan .content-section').forEach(s => s.classList.remove('active'));

            const step1UploadDiv = document.getElementById('configStep1Upload');
            const step2CanvasDiv = document.getElementById('configStep2Points'); 
            const step3ZoneControlsDiv = document.getElementById('configStep3Zones');

            if (stepId === 'configStep1Upload') {
                step1UploadDiv.classList.add('active');
            } else if (stepId === 'configStep2Points') {
                step2CanvasDiv.classList.add('active');
            } else if (stepId === 'configStep3Zones') {
                step2CanvasDiv.classList.add('active'); 
                step3ZoneControlsDiv.classList.add('active');
            }

            isDrawingZoneMode = (stepId === 'configStep3Zones');

            if (isDrawingZoneMode) {
                pointMakerCanvas.style.borderColor = 'blue'; 
            } else {
                pointMakerCanvas.style.borderColor = 'var(--border-color)';
            }
            
            if ((stepId === 'configStep2Points' || stepId === 'configStep3Zones') && selectedFloorplanImage) {
                initializePointMaker();
            }
        }


        dashboardTitle.addEventListener('click', () => showPage('pageDashboardOverview'));
        mainNavButtons.forEach(button => button.addEventListener('click', () => {
            if (button.disabled) return;
            showPage(`page${button.id.replace('nav', '')}`);
        }));
        quickActionProcessVideoBtn.addEventListener('click', () => showPage('pageProcessVideo'));
        quickActionCheckHistoryBtn.addEventListener('click', () => showPage('pageHistory'));

        logoutButton.addEventListener('click', async () => {
            try {
                await fetch(`${backendUrl}/api/logout`, { method: 'POST' });
                window.location.href = '/login';
            } catch (error) { console.error('Logout error:', error); alert('Logout failed.'); }
        });

        function updateLoadedConfigDisplay() {
            const savedName = localStorage.getItem(LOCAL_STORAGE_CONFIG_NAME);
            const savedPointsStr = localStorage.getItem(LOCAL_STORAGE_CONFIG_POINTS);
            const savedZonesStr = localStorage.getItem(LOCAL_STORAGE_ZONES);

            if (savedName) {
                loadedFloorplanNameSpan.textContent = savedName;
                if (savedPointsStr) {
                    const points = JSON.parse(savedPointsStr);
                    loadedPointsStatusSpan.textContent = points.length === 4 ? `${points.length} points set.` : "Perspective points not fully set.";
                } else {
                    loadedPointsStatusSpan.textContent = "Perspective points not set.";
                }
                if (savedZonesStr) {
                    const zones = JSON.parse(savedZonesStr);
                    loadedZonesStatusSpan.textContent = zones.length > 0 ? `${zones.length} zone(s) defined.` : "No zones defined.";
                } else {
                    loadedZonesStatusSpan.textContent = "No zones defined.";
                }
            } else {
                loadedFloorplanNameSpan.textContent = 'None';
                loadedPointsStatusSpan.textContent = "Not Set.";
                loadedZonesStatusSpan.textContent = "Not Set.";
            } // Ensure this closing brace is here
        }


        // --- Configure Floorplan Page Logic ---
        configPage_floorplanUploadFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    floorplanPreviewImage.src = e.target.result;
                    floorplanPreviewContainer.style.display = 'block';
                    selectedFloorplanImage = new Image();
                    selectedFloorplanImage.onload = () => {
                        originalFloorplanWidth = selectedFloorplanImage.naturalWidth;
                        originalFloorplanHeight = selectedFloorplanImage.naturalHeight;
                        console.log("New image uploaded and loaded. Original dimensions:", originalFloorplanWidth, "x", originalFloorplanHeight); 
                        goToPointConfigButton.disabled = false;
                        currentConfigPoints = []; floorplanZones = []; currentDrawingZonePoints = []; 
                        updatePointsListDisplay(); updateDefinedZonesDisplay();
                        goToZoneConfigButton.disabled = true;
                    };
                    selectedFloorplanImage.onerror = () => { alert("Error loading image."); goToPointConfigButton.disabled = true; };
                    selectedFloorplanImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                 selectedFloorplanImage = null; floorplanPreviewContainer.style.display = 'none'; goToPointConfigButton.disabled = true;
            }
        });

        goToPointConfigButton.addEventListener('click', () => {
            if (!selectedFloorplanImage) { alert("Upload floorplan first."); return; }
            showConfigStep('configStep2Points');
        });
        
        goToZoneConfigButton.addEventListener('click', () => {
            if (currentConfigPoints.length !== 4) { alert("Set 4 perspective points first."); return; }
            showConfigStep('configStep3Zones');
        });


        function initializePointMaker() {
            console.log("initializePointMaker called. selectedFloorplanImage exists:", !!selectedFloorplanImage); 
            if (!selectedFloorplanImage || !selectedFloorplanImage.complete || selectedFloorplanImage.naturalWidth === 0) {
                console.error("initializePointMaker: Cannot proceed. selectedFloorplanImage is missing, incomplete, or has no dimensions.", 
                              "Image complete:", selectedFloorplanImage ? selectedFloorplanImage.complete : 'N/A',
                              "Natural width:", selectedFloorplanImage ? selectedFloorplanImage.naturalWidth : 'N/A',
                              "Natural height:", selectedFloorplanImage ? selectedFloorplanImage.naturalHeight : 'N/A');
                if (ctx && pointMakerCanvas.width > 0) ctx.clearRect(0, 0, pointMakerCanvas.width, pointMakerCanvas.height); 
                return;
            }
            
            const currentImageOriginalWidth = selectedFloorplanImage.naturalWidth;
            const currentImageOriginalHeight = selectedFloorplanImage.naturalHeight;
            console.log("initializePointMaker: Using image natural dimensions:", currentImageOriginalWidth, "x", currentImageOriginalHeight);

            const containerWidth = pointMakerCanvas.parentElement.clientWidth * CANVAS_CONTAINER_SCALE_FACTOR;
            const aspectRatio = currentImageOriginalWidth / currentImageOriginalHeight;
            let canvasWidth = currentImageOriginalWidth;
            let canvasHeight = currentImageOriginalHeight;

            if (canvasWidth > containerWidth) {
                canvasWidth = containerWidth;
                canvasHeight = canvasWidth / aspectRatio;
            }
            pointMakerCanvas.width = Math.max(1, canvasWidth); pointMakerCanvas.height = Math.max(1, canvasHeight); 
            console.log("initializePointMaker: Canvas resized to", pointMakerCanvas.width, "x", pointMakerCanvas.height); 
            
            if (!ctx) ctx = pointMakerCanvas.getContext('2d'); 
            ctx.clearRect(0, 0, pointMakerCanvas.width, pointMakerCanvas.height); 
            console.log("initializePointMaker: Canvas cleared."); 
            ctx.drawImage(selectedFloorplanImage, 0, 0, pointMakerCanvas.width, pointMakerCanvas.height);
            console.log("initializePointMaker: ctx.drawImage called for floorplan."); 
            
            const scaleX = pointMakerCanvas.width / currentImageOriginalWidth;
            const scaleY = pointMakerCanvas.height / currentImageOriginalHeight;
            console.log("initializePointMaker: Recalculating display points. ScaleX:", scaleX, "ScaleY:", scaleY); 

            currentConfigPoints.forEach(p => {
                p.displayX = p.originalX * scaleX;
                p.displayY = p.originalY * scaleY;
                drawCanvasPoint(p.displayX, p.displayY, 'red');
            });
            
            floorplanZones.forEach(zone => {
                zone.points.forEach(p => {
                    p.displayX = p.originalX * scaleX;
                    p.displayY = p.originalY * scaleY;
                    drawCanvasPoint(p.displayX, p.displayY, 'rgba(0, 100, 200, 0.6)');
                });
                if (zone.points.length > 1) drawPolygon(zone.points, 'rgba(0, 100, 200, 0.2)');
            });
            
            currentDrawingZonePoints.forEach(p => {
                p.displayX = p.originalX * scaleX;
                p.displayY = p.originalY * scaleY;
                drawCanvasPoint(p.displayX, p.displayY, 'rgba(0, 150, 255, 0.7)');
            });
            if (currentDrawingZonePoints.length > 1) drawPolygon(currentDrawingZonePoints, 'rgba(0, 150, 255, 0.3)');

            updatePointsListDisplay(); 
            goToZoneConfigButton.disabled = currentConfigPoints.length !== 4;
        }

        pointMakerCanvas.addEventListener('click', (event) => {
            console.log("Canvas clicked. isDrawingZoneMode:", isDrawingZoneMode, "selectedFloorplanImage exists:", !!selectedFloorplanImage);
            
            if (!selectedFloorplanImage || selectedFloorplanImage.naturalWidth === 0) { 
                console.log("Canvas clicked, but no valid selectedFloorplanImage. Returning.");
                alert("Please upload and select a floorplan image first in Step 1.");
                return;
            }
            const rect = pointMakerCanvas.getBoundingClientRect();
            const displayX = event.clientX - rect.left;
            const displayY = event.clientY - rect.top;
            
            const currentImageNaturalWidth = selectedFloorplanImage.naturalWidth;
            const currentImageNaturalHeight = selectedFloorplanImage.naturalHeight;
            const originalX = (displayX / pointMakerCanvas.width) * currentImageNaturalWidth;
            const originalY = (displayY / pointMakerCanvas.height) * currentImageNaturalHeight;
            const pointData = { displayX, displayY, originalX, originalY };

            if (isDrawingZoneMode) { 
                console.log("Adding point to currentDrawingZonePoints.");
                currentDrawingZonePoints.push(pointData);
                drawCanvasPoint(displayX, displayY, 'rgba(0, 150, 255, 0.7)'); 
                if (currentDrawingZonePoints.length > 1) drawPolygon(currentDrawingZonePoints, 'rgba(0, 150, 255, 0.3)');
            } else { 
                console.log("Not in zone drawing mode, attempting to add perspective point.");
                if (currentConfigPoints.length < 4) {
                    currentConfigPoints.push(pointData);
                    drawCanvasPoint(displayX, displayY, 'red');
                    updatePointsListDisplay();
                    goToZoneConfigButton.disabled = currentConfigPoints.length !== 4;
                } else {
                    alert("4 perspective points already selected. Reset to change.");
                }
            }
        });


        function drawCanvasPoint(x, y, color) {
            if (!ctx) return; 
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, POINT_MARKER_RADIUS, 0, 2 * Math.PI);
            ctx.fill();
            if (color === 'red') { 
                ctx.strokeStyle = 'white'; ctx.lineWidth = 1; ctx.stroke();
            }
        }
        
        function drawPolygon(points, fillColor) {
            if (!ctx || points.length < 2) return; 
            ctx.beginPath();
            ctx.moveTo(points[0].displayX, points[0].displayY);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].displayX, points[i].displayY);
            }
            if (points.length > 2) { 
                // ctx.closePath(); // Only close if you want a filled polygon, or if it's the final stroke
            }
            if (fillColor && points.length > 2) { // Fill only if it's a proper polygon
                ctx.fillStyle = fillColor;
                ctx.fill();
            }
            ctx.strokeStyle = fillColor.replace('0.3', '0.8').replace('0.2', '0.7'); // Make stroke darker/more opaque
            ctx.lineWidth = 2;
            ctx.stroke();
        }


        function updatePointsListDisplay() {
            pointsList.innerHTML = '';
            currentConfigPoints.forEach((p, i) => {
                const li = document.createElement('li');
                li.textContent = `Perspective Point ${i + 1}: (Orig: ${p.originalX.toFixed(0)}, ${p.originalY.toFixed(0)})`;
                pointsList.appendChild(li);
            });
        }

        resetPointsButton.addEventListener('click', () => {
            currentConfigPoints = []; 
            initializePointMaker(); 
            goToZoneConfigButton.disabled = true;
        });

        startDrawingZoneButton.addEventListener('click', () => {
            showConfigStep('configStep3Zones'); 
            console.log("Start/Add Point to Zone button clicked. isDrawingZoneMode is now:", isDrawingZoneMode);
        });

        finishCurrentZoneButton.addEventListener('click', () => {
            const name = zoneNameInput.value.trim();
            if (!name) { alert("Enter zone name."); return; }
            if (currentDrawingZonePoints.length < 3) { alert("Zone needs at least 3 points."); return; }
            floorplanZones.push({ name: name, points: [...currentDrawingZonePoints] });
            currentDrawingZonePoints = []; zoneNameInput.value = '';
            updateDefinedZonesDisplay();
            initializePointMaker(); 
        });

        clearCurrentZonePointsButton.addEventListener('click', () => {
            currentDrawingZonePoints = [];
            initializePointMaker(); 
        });

        function updateDefinedZonesDisplay() {
            if (floorplanZones.length === 0) {
                definedZonesListDiv.innerHTML = '<strong>Defined Zones:</strong> (None)'; return;
            }
            let listHtml = '<strong>Defined Zones:</strong><ul>';
            floorplanZones.forEach((zone, index) => {
                listHtml += `<li class="zone-item"><span>${zone.name} (${zone.points.length} pts)</span>
                             <button class="action-button" data-zone-index="${index}" onclick="removeZone(${index})">Remove</button>
                             </li>`;
            });
            listHtml += '</ul>';
            definedZonesListDiv.innerHTML = listHtml;
        }

        window.removeZone = function(index) {
            if (confirm(`Remove zone "${floorplanZones[index].name}"?`)) {
                floorplanZones.splice(index, 1);
                updateDefinedZonesDisplay();
                initializePointMaker(); 
            }
        }
        
        saveFullConfigurationButton.addEventListener('click', () => {
            if (currentConfigPoints.length !== 4) { alert("Set 4 perspective points first."); return; }
            if (!selectedFloorplanImage) { alert("Upload floorplan image first."); return; }

            const floorplanFile = configPage_floorplanUploadFile.files[0];
            const floorplanNameToSave = floorplanFile ? floorplanFile.name : localStorage.getItem(LOCAL_STORAGE_CONFIG_NAME);
            
            if (!floorplanNameToSave) {
                alert("Floorplan name is missing. Please ensure an image was uploaded or a previous config exists.");
                return;
            }

            localStorage.setItem(LOCAL_STORAGE_CONFIG_NAME, floorplanNameToSave);
            localStorage.setItem(LOCAL_STORAGE_CONFIG_DATA_URL, selectedFloorplanImage.src);
            localStorage.setItem(LOCAL_STORAGE_CONFIG_POINTS, JSON.stringify(currentConfigPoints.map(p => ({originalX: p.originalX, originalY: p.originalY})))); 
            localStorage.setItem(LOCAL_STORAGE_ZONES, JSON.stringify(floorplanZones.map(zone => ({name: zone.name, points: zone.points.map(p => ({originalX: p.originalX, originalY: p.originalY})) }))));

            alert(`Configuration for "${floorplanNameToSave}" (Points & Zones) saved to browser.`);
            updateLoadedConfigDisplay();
        });


        window.addEventListener('resize', () => {
            if (document.getElementById('pageConfigureFloorplan').classList.contains('active') && selectedFloorplanImage) {
                initializePointMaker();
            }
            if (document.getElementById('pageZoneMapView').classList.contains('active') && latestZoneData && latestZoneData.floorplan_url) {
                zoneMapOverlayCanvas.width = zoneMapFloorplanImage.offsetWidth;
                zoneMapOverlayCanvas.height = zoneMapFloorplanImage.offsetHeight;
                drawZonesOnMap(); 
            }
        });

        // --- Process Video Page Logic ---
        heatmapForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            statusTextSpan.textContent = 'Status: Uploading files...';
            resultsDiv.style.display = 'none'; heatmapImageElem.src = ''; videoLinkElem.href = '#';
            generateHeatmapButton.disabled = true; processVideo_floorplanFile.disabled = true; processVideo_videoFile.disabled = true;

            const pointsToUseStr = localStorage.getItem(LOCAL_STORAGE_CONFIG_POINTS);
            const zonesToUseStr = localStorage.getItem(LOCAL_STORAGE_ZONES);
            let pointsToUse = [];
            if (pointsToUseStr) pointsToUse = JSON.parse(pointsToUseStr);

            if (pointsToUse.length !== 4) {
                alert("Valid 4-point configuration not found. Set in 'Configure Floorplan'.");
                generateHeatmapButton.disabled = false; processVideo_floorplanFile.disabled = false; processVideo_videoFile.disabled = false;
                return;
            }
            if (processVideo_videoFile.files.length === 0 || processVideo_floorplanFile.files.length === 0 || !processVideo_eventTimeInput.value) {
                alert("Ensure video, floorplan, and event time are provided.");
                generateHeatmapButton.disabled = false; processVideo_floorplanFile.disabled = false; processVideo_videoFile.disabled = false;
                return;
            }

            const formData = new FormData();
            formData.append('videoFile', processVideo_videoFile.files[0]);
            formData.append('floorplanFile', processVideo_floorplanFile.files[0]);
            const pointsDataForBackend = pointsToUse.map(p => `${p.originalX.toFixed(0)},${p.originalY.toFixed(0)}`).join('\n');
            formData.append('pointsData', pointsDataForBackend);
            formData.append('videoEventTime', processVideo_eventTimeInput.value);
            if (zonesToUseStr && JSON.parse(zonesToUseStr).length > 0) {
                formData.append('zonesData', zonesToUseStr);
            }

            try {
                const response = await fetch(`${backendUrl}/api/heatmap_jobs`, { method: 'POST', body: formData });
                if (response.status === 401) { window.location.href = '/login'; return; }
                const data = await response.json();
                if (response.ok && data.job_id) {
                    currentJobId = data.job_id;
                    document.getElementById('statusText').textContent = `Status: Processing... (Job ID: ${currentJobId})`;
                    pollJobStatus(currentJobId);
                } else {
                    document.getElementById('statusText').textContent = `Status: Error - ${data.error || 'Submission failed'}`;
                    generateHeatmapButton.disabled = false; processVideo_floorplanFile.disabled = false; processVideo_videoFile.disabled = false;
                }
            } catch (error) {
                console.error('Error submitting job:', error);
                document.getElementById('statusText').textContent = `Status: Error - Could not connect to server.`;
                generateHeatmapButton.disabled = false; processVideo_floorplanFile.disabled = false; processVideo_videoFile.disabled = false;
            }
        });

        async function pollJobStatus(jobId) {
            try {
                const response = await fetch(`${backendUrl}/api/heatmap_jobs/${jobId}/status`);
                const data = await response.json();

                if (response.status === 401) { window.location.href = '/login'; return; }
                if (!response.ok) {
                    document.getElementById('statusText').textContent = `Status: Error checking status - ${data.error || 'Unknown error'}`;
                    const progressBarContainer = statusDiv.querySelector('.progress-bar-container');
                    if(progressBarContainer) progressBarContainer.remove();
                    generateHeatmapButton.disabled = false; processVideo_floorplanFile.disabled = false; processVideo_videoFile.disabled = false;
                    return;
                }

                let statusMessageText = `Status: ${data.status} (Job ID: ${jobId}) ${data.message ? `- ${data.message}` : ''}`;
                document.getElementById('statusText').textContent = statusMessageText;

                let progressBarContainer = statusDiv.querySelector('.progress-bar-container');
                let progressBarFillElem = progressBarContainer ? progressBarContainer.querySelector('.progress-bar-fill') : null;

                if (data.status === 'processing' || data.status === 'pending') {
                    if (!progressBarContainer) {
                        statusDiv.insertAdjacentHTML('beforeend', '<div class="progress-bar-container"><div class="progress-bar-fill" id="progressBarFill">0%</div></div>');
                        progressBarFillElem = document.getElementById('progressBarFill');
                    }
                    const progressMatch = data.message ? data.message.match(/\((\d+)%\)/) : null;
                    if (progressMatch && progressBarFillElem) {
                        progressBarFillElem.style.width = progressMatch[1] + '%';
                        progressBarFillElem.textContent = progressMatch[1] + '%';
                    }
                    setTimeout(() => pollJobStatus(jobId), POLL_INTERVAL_MS);
                } else {
                    if (progressBarFillElem && data.status === 'completed') {
                        progressBarFillElem.style.width = '100%'; progressBarFillElem.textContent = '100%';
                    }
                    setTimeout(() => { if(progressBarContainer) progressBarContainer.remove(); }, 1500);
                    generateHeatmapButton.disabled = false; processVideo_floorplanFile.disabled = false; processVideo_videoFile.disabled = false;
                }

                if (data.status === 'completed') {
                    resultsDiv.style.display = 'block';
                    heatmapImageElem.src = `${backendUrl}/api/heatmap_jobs/${jobId}/result/image?t=${new Date().getTime()}`;
                    videoLinkElem.href = `${backendUrl}/api/heatmap_jobs/${jobId}/result/video`;
                    videoLinkElem.download = `processed_video_${jobId}.mp4`;
                }
            } catch (error) {
                console.error('Error polling status:', error);
                document.getElementById('statusText').textContent = `Status: Error - Could not get job status.`;
                generateHeatmapButton.disabled = false; processVideo_floorplanFile.disabled = false; processVideo_videoFile.disabled = false;
            }
        }

        // --- History Page Logic ---
        async function fetchJobHistory() {
            const tableBody = document.getElementById('historyTableBody');
            const historyMessage = document.getElementById('historyMessage');
            tableBody.innerHTML = '<tr class="history-table-message-row"><td colspan="8">Loading history...</td></tr>';
            historyMessage.textContent = '';

            try {
                const response = await fetch(`${backendUrl}/api/heatmap_jobs/history`);
                if (response.status === 401) { window.location.href = '/login'; return; }
                if (!response.ok) { 
                    const errorData = await response.json().catch(() => ({ detail: "Failed to fetch history, server response not JSON." }));
                    historyMessage.textContent = `Error fetching history: ${errorData.detail || response.statusText}`; 
                    tableBody.innerHTML = '<tr class="history-table-message-row"><td colspan="8">Error loading history.</td></tr>'; 
                    return; 
                }
                
                const jobs = await response.json();
                tableBody.innerHTML = '';
                if (jobs.length === 0) {
                    tableBody.innerHTML = '<tr class="history-table-message-row"><td colspan="8">No history found.</td></tr>';
                } else {
                    jobs.forEach(job => {
                        const row = tableBody.insertRow();
                        
                        row.insertCell().textContent = job.job_id.substring(0, 8) + "..."; // Job ID

                        const videoCell = row.insertCell(); // Video
                        videoCell.textContent = job.input_video_name || 'N/A';
                        videoCell.className = 'history-filename-col';
                        videoCell.title = job.input_video_name || 'N/A'; // Full name on hover

                        const floorplanCell = row.insertCell(); // Floorplan
                        floorplanCell.textContent = job.input_floorplan_name || 'N/A';
                        floorplanCell.className = 'history-floorplan-col'; 
                        floorplanCell.title = job.input_floorplan_name || 'N/A'; 

                        row.insertCell().textContent = job.people_counted !== null ? job.people_counted : 'N/A'; // People
                        row.insertCell().textContent = job.status; // Status
                        
                        const messageCell = row.insertCell(); // Message
                        messageCell.textContent = job.message || 'N/A';
                        messageCell.className = 'history-message-col';
                        
                        row.insertCell().textContent = job.video_event_timestamp ? new Date(job.video_event_timestamp).toLocaleString() : (job.created_at ? new Date(job.created_at).toLocaleString() : 'N/A'); // Event Time
                        
                        const actionsCell = row.insertCell();
                        actionsCell.className = 'history-actions-col';
                        if (job.status === 'completed') {
                            actionsCell.innerHTML = `<a href="${backendUrl}/api/heatmap_jobs/${job.job_id}/result/image" target="_blank">View Image</a> | <a href="${backendUrl}/api/heatmap_jobs/${job.job_id}/result/video">Download Video</a>`;
                        }
                    });
                }
            } catch (error) {
                console.error("Error fetching history:", error);
                historyMessage.textContent = 'Failed to load history.'; 
                tableBody.innerHTML = '<tr class="history-table-message-row"><td colspan="8">Error loading history.</td></tr>';
            }
        }

        function loadConfigIntoPointMaker() {
            const savedDataURL = localStorage.getItem(LOCAL_STORAGE_CONFIG_DATA_URL);
            const savedPointsStr = localStorage.getItem(LOCAL_STORAGE_CONFIG_POINTS);
            const savedZonesStr = localStorage.getItem(LOCAL_STORAGE_ZONES);

            currentConfigPoints = []; floorplanZones = []; 
            if (savedPointsStr) currentConfigPoints = JSON.parse(savedPointsStr).map(p => ({...p, displayX:0, displayY:0})); 
            if (savedZonesStr) {
                floorplanZones = JSON.parse(savedZonesStr).map(zone => ({
                    ...zone,
                    points: zone.points.map(p => ({...p, displayX:0, displayY:0}))
                }));
            }
            updateDefinedZonesDisplay();

            if (savedDataURL) {
                selectedFloorplanImage = new Image();
                selectedFloorplanImage.onload = () => {
                    originalFloorplanWidth = selectedFloorplanImage.naturalWidth;
                    originalFloorplanHeight = selectedFloorplanImage.naturalHeight;
                    console.log("Image from localStorage loaded. Original dimensions:", originalFloorplanWidth, "x", originalFloorplanHeight); 
                    floorplanPreviewImage.src = savedDataURL;
                    floorplanPreviewContainer.style.display = 'block';
                    goToPointConfigButton.disabled = false;
                    
                    const activeConfigPage = document.getElementById('pageConfigureFloorplan').classList.contains('active');
                    const activeConfigStep2 = document.getElementById('configStep2Points').classList.contains('active');
                    const activeConfigStep3 = document.getElementById('configStep3Zones').classList.contains('active');
                    if (activeConfigPage && (activeConfigStep2 || activeConfigStep3)) {
                        initializePointMaker();
                    }
                };
                selectedFloorplanImage.src = savedDataURL;
            } else {
                selectedFloorplanImage = null;
                floorplanPreviewContainer.style.display = 'none';
                goToPointConfigButton.disabled = true;
                if (ctx && pointMakerCanvas.width > 0) ctx.clearRect(0,0, pointMakerCanvas.width, pointMakerCanvas.height);
                updatePointsListDisplay();
            }
            updateLoadedConfigDisplay();
        }

        // --- Zone Map View Page Logic ---
        let zoneMapCtx = null;
        let latestZoneData = null; 

        function loadZoneMapView() {
            console.log("Loading Zone Map View...");
            zoneMapFloorplanImage.src = ''; 
            zoneMapOverlayCanvas.width = 0; 
            zoneMapOverlayCanvas.height = 0;
            zoneHoverInfo.style.display = 'none';
            zoneMapMessage.textContent = 'Loading latest zone data...';

            fetchLatestZoneMapData();
        }

        async function fetchLatestZoneMapData() {
            try {
                const response = await fetch(`${backendUrl}/api/latest_zone_map_data`);
                if (response.status === 401) { window.location.href = '/login'; return; }
                
                const data = await response.json();

                if (!response.ok) {
                     zoneMapMessage.textContent = data.message || data.error || 'Error fetching zone map data.';
                     console.error("Error fetching latest zone map data:", data.error || response.statusText);
                     latestZoneData = null;
                     return;
                }

                latestZoneData = data;
                zoneMapMessage.textContent = ''; 

                zoneMapFloorplanImage.onload = () => {
                    console.log("Zone map floorplan image loaded. Natural WxH:", zoneMapFloorplanImage.naturalWidth, "x", zoneMapFloorplanImage.naturalHeight);
                    zoneMapOverlayCanvas.width = zoneMapFloorplanImage.offsetWidth;
                    zoneMapOverlayCanvas.height = zoneMapFloorplanImage.offsetHeight;
                    console.log("Zone map overlay canvas resized to:", zoneMapOverlayCanvas.width, "x", zoneMapOverlayCanvas.height);
                    if (!zoneMapCtx) zoneMapCtx = zoneMapOverlayCanvas.getContext('2d');
                    drawZonesOnMap();
                    setupZoneHover();
                };
                zoneMapFloorplanImage.onerror = () => {
                    zoneMapMessage.textContent = 'Error loading floorplan image for map view.';
                    console.error("Error loading zone map floorplan image:", data.floorplan_url);
                    latestZoneData = null;
                };
                zoneMapFloorplanImage.src = data.floorplan_url;

            } catch (error) {
                console.error("Error fetching latest zone map data:", error);
                zoneMapMessage.textContent = 'Could not connect to server to load zone map data.';
                latestZoneData = null;
            }
        }

        function drawZonesOnMap() {
            if (!zoneMapCtx || !latestZoneData || !latestZoneData.zone_definitions || !zoneMapFloorplanImage.complete || zoneMapFloorplanImage.naturalWidth === 0) {
                console.warn("drawZonesOnMap: Cannot draw, missing context, data, or valid floorplan image dimensions.");
                return;
            }

            zoneMapCtx.clearRect(0, 0, zoneMapOverlayCanvas.width, zoneMapOverlayCanvas.height);

            const originalWidth = zoneMapFloorplanImage.naturalWidth;
            const originalHeight = zoneMapFloorplanImage.naturalHeight;
            const scaleX = zoneMapOverlayCanvas.width / originalWidth;
            const scaleY = zoneMapOverlayCanvas.height / originalHeight;

            latestZoneData.zone_definitions.forEach(zone => {
                if (zone.points.length < 3) return; 

                zoneMapCtx.beginPath();
                zoneMapCtx.moveTo(zone.points[0].originalX * scaleX, zone.points[0].originalY * scaleY);
                for (let i = 1; i < zone.points.length; i++) {
                    zoneMapCtx.lineTo(zone.points[i].originalX * scaleX, zone.points[i].originalY * scaleY);
                }
                zoneMapCtx.closePath();

                zoneMapCtx.fillStyle = 'rgba(0, 100, 200, 0.3)'; 
                zoneMapCtx.fill();
                zoneMapCtx.strokeStyle = 'rgba(0, 100, 200, 0.8)'; 
                zoneMapCtx.lineWidth = 2;
                zoneMapCtx.stroke();
            });
        }

        function setupZoneHover() {
             if (!zoneMapOverlayCanvas || !latestZoneData || !latestZoneData.zone_definitions || !latestZoneData.zone_traffic_results || !zoneMapFloorplanImage.complete || zoneMapFloorplanImage.naturalWidth === 0) {
                 console.warn("setupZoneHover: Cannot setup, missing elements, data, or valid floorplan image dimensions.");
                 return;
             }
             
             const tempCanvas = document.createElement('canvas'); 
             tempCanvas.width = zoneMapOverlayCanvas.width;
             tempCanvas.height = zoneMapOverlayCanvas.height;
             const tempCtx = tempCanvas.getContext('2d');

             const originalWidth = zoneMapFloorplanImage.naturalWidth;
             const originalHeight = zoneMapFloorplanImage.naturalHeight;
             const scaleX = zoneMapOverlayCanvas.width / originalWidth;
             const scaleY = zoneMapOverlayCanvas.height / originalHeight;

             zoneMapOverlayCanvas.onmousemove = (event) => { 
                 const rect = zoneMapOverlayCanvas.getBoundingClientRect();
                 const mouseX = event.clientX - rect.left;
                 const mouseY = event.clientY - rect.top;
                 let hoveredZone = null;

                 for (const zone of latestZoneData.zone_definitions) {
                     if (zone.points.length < 3) continue;
                     tempCtx.beginPath();
                     tempCtx.moveTo(zone.points[0].originalX * scaleX, zone.points[0].originalY * scaleY);
                     for (let i = 1; i < zone.points.length; i++) {
                         tempCtx.lineTo(zone.points[i].originalX * scaleX, zone.points[i].originalY * scaleY);
                     }
                     tempCtx.closePath();
                     if (tempCtx.isPointInPath(mouseX, mouseY)) {
                         hoveredZone = zone;
                         break; 
                     }
                 }

                 if (hoveredZone) {
                     const zoneName = hoveredZone.name;
                     const activityCount = latestZoneData.zone_traffic_results[zoneName] || 0;
                     zoneHoverInfo.textContent = `${zoneName}: ${activityCount} activity units`;
                     zoneHoverInfo.style.left = `${mouseX + 10}px`; 
                     zoneHoverInfo.style.top = `${mouseY + 10}px`;
                     zoneHoverInfo.style.display = 'block';
                 } else {
                     zoneHoverInfo.style.display = 'none';
                 }
             };

             zoneMapOverlayCanvas.onmouseleave = () => { 
                 zoneHoverInfo.style.display = 'none';
             };
        }


        // --- Dashboard Overview Page Logic ---
        async function updateDashboardOverview() {
            totalVisitorsCountElem.textContent = 'Loading...';
            peakHoursInfoElem.textContent = 'Loading...';
            zoneTrafficList.innerHTML = '<p>Loading zone data...</p>';
            zoneAnalyticsContainer.style.display = 'block'; 
            document.getElementById('peakHoursChartContainer').innerHTML = '<canvas id="peakHoursChart"></canvas>'; // Reset canvas container

            if (peakHoursChartInstance) { peakHoursChartInstance.destroy(); peakHoursChartInstance = null; }
            
            const selectedPeriod = document.querySelector('input[name="chartPeriod"]:checked').value;
            console.log("Updating dashboard overview for period:", selectedPeriod);

            try {
                const response = await fetch(`${backendUrl}/api/analytics/overview?chart_period=${selectedPeriod}`);
                if (response.status === 401) { window.location.href = '/login'; return; }
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: "Failed to fetch overview data." }));
                    throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log("Dashboard Overview Data Received:", JSON.stringify(data, null, 2)); 

                // Get current theme colors for the chart
                const style = getComputedStyle(document.body); // Get styles from body, where .dark-mode is applied
                const chartTextColor = style.getPropertyValue('--text-primary').trim(); // Use primary text for better contrast
                const chartGridColor = style.getPropertyValue('--border-light').trim();
                const chartAxisColor = style.getPropertyValue('--border-color').trim();
                const chartBarBackgroundColor = style.getPropertyValue('--primary-color').trim();
                const chartBarBorderColor = style.getPropertyValue('--primary-hover-color').trim();


                totalVisitorsCountElem.textContent = data.total_visitors_today !== null ? data.total_visitors_today : 'N/A';
                
                let chartLabels, chartDataPoints, chartXAxisLabel, chartYAxisLabel, chartTitleText;

                if (data.chart_period_type === 'daily_hourly' && data.chart_data.hourly_visitor_data) {
                    mainChartTitleElem.textContent = "Hourly Traffic (Today)";
                    peakHoursInfoElem.textContent = (data.peak_hour_today && !data.peak_hour_today.startsWith("N/A")) ? 
                        `Peak activity: ${data.peak_hour_today} (with ${data.peak_hour_visitor_count} visitors)` : 
                        'No peak hour data for today. Process videos.';
                    
                    chartLabels = data.chart_data.hourly_visitor_data.map(item => `${item.hour}:00`);
                    chartDataPoints = data.chart_data.hourly_visitor_data.map(item => item.count);
                    chartXAxisLabel = 'Hour of Day';
                    chartYAxisLabel = 'Number of Visitors';
                    chartTitleText = 'Hourly Visitors Today';

                } else if (data.chart_period_type === 'yearly_monthly' && data.chart_data.yearly_visitor_summary) {
                    mainChartTitleElem.textContent = "Monthly Trends (Current Year)";
                    peakHoursInfoElem.textContent = 'Displaying total visitors per month for the current year.';

                    chartLabels = data.chart_data.yearly_visitor_summary.map(item => item.month_name);
                    chartDataPoints = data.chart_data.yearly_visitor_summary.map(item => item.count);
                    chartXAxisLabel = 'Month';
                    chartYAxisLabel = 'Total Visitors';
                    chartTitleText = 'Monthly Visitors This Year';
                } else {
                    console.error("Unknown chart_period_type or missing chart_data:", data.chart_period_type, data.chart_data);
                    document.getElementById('peakHoursChartContainer').innerHTML = '<small style="display:flex; align-items:center; justify-content:center; height:100%; color:#6c757d;">Invalid chart data received.</small>';
                    peakHoursInfoElem.textContent = 'Could not load chart data.';
                }

                if (chartLabels && chartDataPoints) {
                    const chartCanvas = document.getElementById('peakHoursChart').getContext('2d');
                    peakHoursChartInstance = new Chart(chartCanvas, {
                        type: 'bar', 
                        data: { 
                            labels: chartLabels, 
                            datasets: [{ 
                                label: chartTitleText, 
                                data: chartDataPoints, 
                                backgroundColor: chartBarBackgroundColor, 
                                borderColor: chartBarBorderColor, 
                                borderWidth: 1 
                            }] 
                        },
                        options: { 
                            responsive: true, 
                            maintainAspectRatio: false, 
                            scales: { 
                                y: { 
                                    beginAtZero: true, 
                                    title: { 
                                        display: true, 
                                        text: chartYAxisLabel,
                                        color: chartTextColor 
                                    }, 
                                    ticks: { 
                                        stepSize: 1,
                                        color: chartTextColor
                                    },
                                    grid: {
                                        color: chartGridColor,
                                        borderColor: chartAxisColor // For the axis line itself
                                    },
                                    border: { // Explicitly color the axis line
                                        color: chartAxisColor
                                    }
                                }, 
                                x: { 
                                    title: { 
                                        display: true, 
                                        text: chartXAxisLabel,
                                        color: chartTextColor
                                    },
                                    ticks: {
                                        color: chartTextColor
                                    },
                                    grid: {
                                        color: chartGridColor,
                                        borderColor: chartAxisColor // For the axis line itself
                                    },
                                    border: { // Explicitly color the axis line
                                        color: chartAxisColor
                                    }
                                } 
                            }, 
                            plugins: { 
                                legend: { 
                                    display: true, 
                                    labels: {
                                        boxWidth: 20,
                                        color: chartTextColor
                                    } 
                                } 
                            } 
                        }
                    });
                } else if (!document.getElementById('peakHoursChartContainer').innerHTML.includes('small')) { 
                     document.getElementById('peakHoursChartContainer').innerHTML = '<small style="display:flex; align-items:center; justify-content:center; height:100%; color:#6c757d;">No data available for the selected chart period.</small>';
                }


                if (data.zone_traffic_summary && data.zone_traffic_summary.length > 0) {
                    let zoneHtml = '<ul>';
                    data.zone_traffic_summary.forEach(zone => {
                        zoneHtml += `<li><strong>${zone.name}:</strong> ${zone.percentage.toFixed(1)}% traffic (${zone.count} activity units, ${zone.classification})</li>`;
                    });
                    zoneHtml += '</ul>';
                    zoneTrafficList.innerHTML = zoneHtml;
                } else {
                    zoneTrafficList.innerHTML = '<p>No zone-specific traffic data available for today. Ensure videos are processed with defined zones.</p>';
                }


            } catch (error) {
                console.error("Error fetching dashboard overview:", error);
                totalVisitorsCountElem.textContent = 'Error';
                peakHoursInfoElem.textContent = 'Could not load peak hours.';
                document.getElementById('peakHoursChartContainer').innerHTML = '<small style="display:flex; align-items:center; justify-content:center; height:100%; color:red;">Error loading chart.</small>';
                zoneTrafficList.innerHTML = '<p style="color:red;">Error loading zone traffic data.</p>';
            }
        }
        
        chartPeriodRadios.forEach(radio => {
            radio.addEventListener('change', updateDashboardOverview);
        });
        
        // Responsive adjustments for dashboard layout (add to existing resize listener or make new one)
        function adjustDashboardLayout() {
            const grid = document.querySelector('.dashboard-layout-grid');
            if (!grid) return;

            if (window.innerWidth <= 992) { // Example breakpoint
                grid.style.flexDirection = 'column';
            } else {
                grid.style.flexDirection = 'row';
            }
        }
        window.addEventListener('resize', adjustDashboardLayout);

        // Dark Mode Toggle Logic
        const themeToggleCheckbox = document.getElementById('themeToggleCheckbox');
        const themeLabel = document.getElementById('themeLabel');
        const currentBody = document.body; // Renamed to avoid conflict if 'body' var is used elsewhere

        function applyTheme(theme) {
            if (theme === 'dark') {
                currentBody.classList.add('dark-mode');
                if(themeToggleCheckbox) themeToggleCheckbox.checked = true;
                if(themeLabel) themeLabel.textContent = 'Dark Mode';
            } else {
                currentBody.classList.remove('dark-mode');
                if(themeToggleCheckbox) themeToggleCheckbox.checked = false;
                if(themeLabel) themeLabel.textContent = 'Light Mode';
            }
            // If dashboard overview is active and chart exists, refresh it
            if (document.getElementById('pageDashboardOverview').classList.contains('active')) {
                // updateDashboardOverview will destroy and recreate the chart with new colors
                // No need to check for peakHoursChartInstance specifically, updateDashboardOverview handles it
                updateDashboardOverview();
            }
        }

        const savedTheme = localStorage.getItem('theme') || 'light'; // Default to light
        applyTheme(savedTheme);

        if(themeToggleCheckbox) {
            themeToggleCheckbox.addEventListener('change', () => {
                const newTheme = themeToggleCheckbox.checked ? 'dark' : 'light';
                applyTheme(newTheme);
                localStorage.setItem('theme', newTheme);
            });
        }

        // --- Initial Setup ---
        if (pointMakerCanvas) ctx = pointMakerCanvas.getContext('2d');
        showPage('pageDashboardOverview');
    </script>
</body>
</html>
